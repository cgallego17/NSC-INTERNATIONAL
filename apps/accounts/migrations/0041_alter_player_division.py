# Generated by Django 6.0 on 2026-01-08 19:32

import django.db.models.deletion
from django.db import migrations, models, connection
from django.db.migrations.operations import SeparateDatabaseAndState


def preserve_division_data(apps, schema_editor):
    """Preserva los datos de división ANTES de cambiar el campo usando raw SQL"""
    # Leer directamente desde la base de datos usando raw SQL
    # Esto funciona porque todavía el campo es CharField
    with connection.cursor() as cursor:
        # Verificar que la columna existe y leer los datos
        cursor.execute(
            """
            SELECT id, division
            FROM accounts_player
            WHERE division IS NOT NULL AND division != ''
        """
        )
        division_data = dict(cursor.fetchall())

        # Guardar en una tabla temporal usando una tabla separada
        # Crear tabla temporal si no existe (usar DROP IF EXISTS primero para evitar errores)
        cursor.execute("DROP TABLE IF EXISTS accounts_player_division_temp")
        cursor.execute(
            """
            CREATE TABLE accounts_player_division_temp (
                player_id INTEGER PRIMARY KEY,
                division_value VARCHAR(10)
            )
        """
        )

        # Insertar datos en la tabla temporal usando executemany
        if division_data:
            insert_data = [
                (int(player_id), str(division_value) if division_value else "")
                for player_id, division_value in division_data.items()
                if division_value
            ]
            if insert_data:
                cursor.executemany(
                    """
                    INSERT INTO accounts_player_division_temp (player_id, division_value)
                    VALUES (?, ?)
                """,
                    insert_data,
                )

        # NOTA: No ponemos los valores a NULL aquí porque el campo tiene restricción NOT NULL
        # En su lugar, cuando Django cambie el campo de CharField a ForeignKey,
        # SQLite recreará la columna y los valores se perderán temporalmente.
        # Luego, migrate_division_data restaurará los valores usando la tabla temporal.


def migrate_division_data(apps, schema_editor):
    """Migra los datos de división a la columna temporal division_id_temp"""
    Division = apps.get_model("events", "Division")

    # Leer los datos desde la tabla temporal
    with connection.cursor() as cursor:
        try:
            cursor.execute(
                """
                SELECT player_id, division_value
                FROM accounts_player_division_temp
            """
            )
            division_data = dict(cursor.fetchall())
        except Exception:
            # Si la tabla no existe, no hay datos que migrar
            division_data = {}

    # Migrar cada jugador a la columna temporal division_id_temp
    for player_id, old_division_value in division_data.items():
        if not old_division_value:
            continue

        division_name = str(old_division_value).strip()

        # Buscar división existente o crear
        division = None

        # Intentar encontrar por nombre exacto
        try:
            division = Division.objects.get(name=division_name)
        except Division.DoesNotExist:
            # Buscar por parte del nombre (ej: "10U" para "10U D1")
            base_name = (
                division_name.split()[0] if " " in division_name else division_name
            )
            division = Division.objects.filter(name__startswith=base_name).first()

            # Si no existe, crear una nueva división simple
            if not division:
                division = Division.objects.create(name=base_name, is_active=True)

        # Actualizar usando raw SQL directamente
        if division:
            with connection.cursor() as update_cursor:
                # Verificar que la columna existe antes de actualizar
                update_cursor.execute("PRAGMA table_info(accounts_player)")
                columns = [col[1] for col in update_cursor.fetchall()]
                if "division_id_temp" not in columns:
                    # Si la columna no existe, crearla primero
                    update_cursor.execute(
                        "ALTER TABLE accounts_player ADD COLUMN division_id_temp INTEGER REFERENCES events_division(id);"
                    )
                # Usar parámetros correctamente para SQLite (? en lugar de %s)
                # Usar execute con parámetros como tupla para evitar problemas con debug SQL
                sql = "UPDATE accounts_player SET division_id_temp = ? WHERE id = ?"
                params = (division.id, player_id)
                # Ejecutar directamente sin pasar por el debug SQL de Django
                update_cursor.execute(sql, params)

    # Limpiar la tabla temporal
    with connection.cursor() as cursor:
        cursor.execute("DROP TABLE IF EXISTS accounts_player_division_temp")


def reverse_migrate_division_data(apps, schema_editor):
    """Reversa la migración - limpiar tabla temporal si existe"""
    with connection.cursor() as cursor:
        cursor.execute("DROP TABLE IF EXISTS accounts_player_division_temp")


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0040_add_payment_plan_fields_to_order"),
        ("events", "0029_event_service_fee"),
    ]

    operations = [
        migrations.RunPython(preserve_division_data, reverse_migrate_division_data),
        SeparateDatabaseAndState(
            # Cambio de estado del modelo (lo que Django cree que es el estado)
            state_operations=[
                migrations.AlterField(
                    model_name="player",
                    name="division",
                    field=models.ForeignKey(
                        blank=True,
                        help_text="División en la que el jugador está asignado",
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        related_name="players",
                        to="events.division",
                        verbose_name="División Asignada",
                    ),
                ),
            ],
            # Operaciones de base de datos (lo que realmente hacemos en la DB)
            database_operations=[
                # Primero eliminar la columna antigua
                migrations.RunSQL(
                    sql="ALTER TABLE accounts_player ADD COLUMN division_id_temp INTEGER REFERENCES events_division(id);",
                    reverse_sql="ALTER TABLE accounts_player DROP COLUMN division_id_temp;",
                ),
                # Migrar los datos
                migrations.RunPython(
                    migrate_division_data, reverse_migrate_division_data
                ),
                # Eliminar la columna antigua y renombrar la nueva
                migrations.RunSQL(
                    sql=[
                        "ALTER TABLE accounts_player DROP COLUMN division;",
                        "ALTER TABLE accounts_player RENAME COLUMN division_id_temp TO division_id;",
                    ],
                    reverse_sql=[
                        "ALTER TABLE accounts_player RENAME COLUMN division_id TO division_id_temp;",
                        "ALTER TABLE accounts_player ADD COLUMN division VARCHAR(10);",
                    ],
                ),
            ],
        ),
    ]
